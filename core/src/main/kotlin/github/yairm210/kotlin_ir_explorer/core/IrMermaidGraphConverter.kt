package github.yairm210.kotlin_ir_explorer.core

import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrDeclarationWithName
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.util.render
import org.jetbrains.kotlin.ir.visitors.IrElementVisitor

object IrMermaidGraphConverter {
    fun convertToMermaidGraph(irModuleFragment: IrModuleFragment,
                              /** Whether to add a comment that shows the start-end positions of each element in the input text
                               * Note that this causes the graph to not render properly despite the comment being ostensibly valid mermaid :|
                               * */
                              withOffsetComment: Boolean = false): String {
        val sb = StringBuilder()
        sb.appendLine("graph TD")
        irModuleFragment.files.forEach { file ->
            file.accept(IrMermaidGraphListener(withOffsetComment), Triple(null, sb, 0))
        }
        return sb.toString()
    }
}

class IrMermaidGraphListener(val withOffsetComment: Boolean) :IrElementVisitor<Unit, Triple<IrElement?, StringBuilder, Int>> {
    override fun visitElement(element: IrElement, data: Triple<IrElement?, StringBuilder, Int>) {
        val (parent, stringbuilder:StringBuilder, depth) = data
        
        // Don't use stringbuilder.repeat since it's new to JVM 21
        stringbuilder.append("  ".repeat(depth))

        val offsetComment = if (withOffsetComment) " %% Offset: ${element.startOffset}-${element.endOffset}"
            else ""
        
        // Need to escape the rendered string to avoid issues with mermaid
        val elementText = "\"${element::class.simpleName}\n" +
                "${element.render()}\""
        stringbuilder.appendLine("${element.hashCode()}[$elementText]$offsetComment")
        
        
        // IDs of the elements are the hashcodes
        if (parent != null) {
            stringbuilder.append("  ".repeat(depth))
            stringbuilder.appendLine("${parent.hashCode()} --> ${element.hashCode()}")
        }
        listOf(1,2).max()

        // The subgraph should not hold the block body containing the function declaration, hence it can't be at the top of this function
        if (element is IrFunction || element is IrClass) {
            val name = (element as IrDeclarationWithName).name.asString()
            // Autogenerated functions are wrapped in <these> so Mermaid interprets them as HTML-like tags making the text invisible
            val functionNameNotHtmlLike = element.name.asString().removePrefix("<").removeSuffix(">")
            // Each class has autogenerated functions with the same name - we don't want them mapping to the same subgraph
            val prefix = if (parent is IrDeclarationWithName) "${parent.name.asString()}." else ""
            stringbuilder.appendLine("subgraph \"$prefix$functionNameNotHtmlLike\"")
        }
        
        // User-visible text is just the classname for now
        element.acceptChildren(this, Triple(element, stringbuilder, depth + 1))
        
        if (element is IrFunction || element is IrClass) {
            stringbuilder.appendLine("end")
        }
    }
}